# **Проект TestOnlineShop**

## **Учебно-тестовая база данных интернет магазина "КомпАсс".** 

## Магазин занимается продажей компьютерной техники и комплектующих для компьютеров.
---
> ## Для учета продаж товаров в интернет магазине используется приложение, которое хранит данные в реляционной базе данных. Приложение позволяет хранить информацию о товарах, покупателях и заказах. Для этого в базе данных были созданы следующие таблицы:

 - **buyers** – *таблица покупателей;*
   - **buyer_id** – идентификатор покупателя;
   - **buyer_name** – ФИО покупателя;
   - **birthday** – день рождения покупателя.
- **orders** – *таблица заказов;*
   - **order_id** – идентификатор заказа;
   - **buyer_id** – идентификатор покупателя, ссылка на таблицу **buyers**;
   - **order_number** – номер заказа;
   - **order_date** – дата заказа;
   - **order_summa** – сумма заказа. 
- **products** – *таблица товаров;*
   - **product_id** – идентификатор товара;
   - **product_name** – наименование товара;
   - **description** – описание товара;
   - **price** – стоимость товара;
   - **type_id** – тип товара, ссылка на таблицу.
- **product_types** – *таблица типов товаров;*
   - **type_id** – идентификатор типа товара;
   - **name** – наименование типа товара.
- **orders_products** – *таблица связи заказов и товаров.*
   - **order_id** – идентификатор заказа, ссылка на таблицу orders;
   - **product_id** – идентификатор товара, ссылка на таблицу products.
  ---
> ### **Код созданных таблиц:**
```sql
CREATE TABLE buyers(
	buyer_id INT NOT NULL,
	buyer_name VARCHAR(100) NOT NULL,
	birthday DATE NOT NULL
);

CREATE TABLE orders(
	order_id INT NOT NULL,
	buyer_id INT NOT NULL,
	order_number INT NOT NULL,
	order_date DATE NOT NULL,
	order_summa MONEY NOT NULL
);

CREATE TABLE product_types(
	type_id INT NOT NULL,
	name VARCHAR(100) NOT NULL
);

CREATE TABLE products(
	product_id INT NOT NULL,
	product_name VARCHAR(100) NOT NULL,
	description VARCHAR(200) NULL,
	price MONEY NULL,
	type_id INT NOT NULL
);

CREATE TABLE orders_products(
	order_id INT NOT NULL,
	product_id INT NOT NULL
);
```
---
> ### **Код добавления данных в таблицы:**

```sql
INSERT INTO buyers (buyer_id, buyer_name, birthday)
	VALUES (753, 'Зайцев А.Е.', '1998.04.12'),
		   (832, 'Иванов И.И.', '1993.07.16'),
		   (991, 'Попова Е.В.', '2001.10.28'),
		   (1028, 'John Smith', '2000.05.03'),
		   (1109, 'Сергеев А.С.', '1986.10.12'),
		   (1177, 'Петров С.Л.', '2003.06.11'),
		   (1201, 'Андреев В.А.', '1980.09.27');
		   
INSERT INTO orders (order_id, buyer_id, order_number, order_date, order_summa)
	VALUES (1459, 1201, 151, '2020.04.02', 12750),
		   (1567, 991, 259, '2020.04.17', 6700),
		   (1615, 832, 307, '2020.05.02', 21440),
		   (1646, 1109, 338, '2020.05.07', 15540),
		   (1660, 1201, 352, '2020.05.16', 2100),
		   (1708, 832, 400, '2020.05.21', 6700),
		   (1718, 1028, 410, '2020.05.21', 12300),
		   (1893, 832, 115, '2020.06.11', 4600),
		   (1923, 1109, 85, '2020.06.29', 23990),
		   (1959, 1201, 151, '2020.07.02', 1300),
		   (2052, 832, 244, '2020.07.30', 7900),
		   (2057, 991, 249, '2020.07.30', 16900),
		   (2106, 753, 298, '2020.08.08', 900),
		   (2146, 1201, 338, '2020.08.15', 2200),
		   (2181, 832, 373, '2020.08.23', 16740);

INSERT INTO product_types (type_id, name)
	VALUES (1, 'Физический'),
		   (2, 'Цифровой');

INSERT INTO products (product_id, product_name, description, price, type_id)
	VALUES (16, 'Процессор V5', '4-ядерный процессор, 3600 МГц', 12300, 1),
		   (29, 'Материнская плата R7Q', '2 слота DDR4, 1 слот PCI-E', 4600, 1),
		   (38, 'Клавиатура S939', 'Проводная, интерфейс USB', 1300, 1),
		   (47, 'Мышь N56', 'USB', 900, 1),
		   (60, 'Материнская плата ES20', '4 слота DDR4, 2 слота PCI-E', 6700, 1),
		   (71, 'Принтер 3075', 'Лазерный, 20 стр/мин (A4), USB', 3500, 1),
		   (83, 'Кулер для процессора D17', NULL, 450, 1),
		   (96, 'Процессор V7', '6-ядерный процессор, 3700 МГц', 15540, 1),
		   (108, 'Антивирусная программа', NULL, 1200, 2),
		   (125, 'Операционная система', NULL, 6700, 2);
		   
INSERT INTO orders_products (order_id, product_id)
	VALUES (1459, 16), (1459, 83), (1567, 125), (1615, 29),
		   (1615, 96), (1615, 38), (1646, 96), (1660, 108),
		   (1660, 47), (1708, 60), (1718, 16), (1893, 29),
		   (1923, 60), (1923, 83), (1923, 96), (1923, 38),
		   (1959, 38), (2052, 108), (2052, 125), (2057, 16),
		   (2057, 29), (2106, 47), (2146, 38), (2146, 47),
		   (2181, 108), (2181, 96);
```
---
> ### **1. Например появилась необходимость сформировать перечень всех товаров с указанием их цены.**
> ### **Код SQL инструкции:**
```sql
SELECT product_name, price
FROM products;
```
#### Результат:
product_name | price
:--- | :--- |
Процессор V5 | 13530,00
Материнская плата R7Q |	5060,00
Клавиатура S939 | 1430,00
Мышь N56 | 990,00
Материнская плата ES20 | 7370,00
Принтер 3075 | 3850,00
Кулер для процессора D17 | 495,00
Процессор V7 | 17094,00
Антивирусная программа | 1200,00
Операционная система | 6700,00

### В SQL запросе, обращаясь к таблице ***products***, все данные товаров и их цен получаем из столбцов ***product_name, price***
---
> ### **2. Например в процессе работы магазина понадобилось узнать дату рождения всех покупателей, к тому же, нужно выгрузить список всех покупателей с указанием даты их рождения.**
> *Нужен запрос который покажет ФИО и дату рождения всех покупателей.*

```sql
SELECT buyer_name, birthday
FROM buyers;
```
#### Результат:

buyer_name | birthday
:--- | :--- 
Зайцев А.Е. | 1998-04-12
Иванов И.И. | 1993-07-16
Попова Е.В. | 2001-10-28
John Smith  | 2000-05-03
Сергеев А.С.| 1986-10-12
Андреев В.А.| 1980-09-27

### Получить нужно не все столбцы таблицы, а только ФИО и даты рождения, поэтому в списке выборки инструкции **SELECT** указывается только два соответствующих столбца ***buyer_name, birthday***
---
> ### **3. Задача сформировать список всех заказов с указанием номера, даты и суммы заказа.** 
> *Нужен запрос, который покажет номер, дату и сумму всех заказов.*

```sql
SELECT order_number, order_date, order_summa
FROM orders;
```
#### Результат:
order_number | order_date |	order_summa
:--- | :--- | :--- 
151 |	2020-04-02 |	12750,00
259 |	2020-04-17 |	6700,00
307 |	2020-05-02 |	21440,00
338 |	2020-05-07 |	15540,00
352 |	2020-05-16 |	2100,00
400 |	2020-05-21 |	6700,00
410 |	2020-05-21 |	12300,00
115 |	2020-06-11 |	4600,00
85 |	2020-06-29 |	23990,00
151 |	2020-07-02 |	1300,00
244 |	2020-07-30 |	7900,00
249 |	2020-07-30 |	16900,00
298 |	2020-08-08 |	900,00
338 |	2020-08-15 |	2200,00
373 |	2020-08-23 |	16740,00

### Необходимо получить номер, дату и сумму заказа, поэтому в списке выборки инструкции **SELECT** указывается только три соответствующих столбца ***order_number, order_date	,order_summa.***
---
> ### **4. Задача посмотреть, какие типы товаров существуют в магазине.**
> *Необходимо написать запрос, который покажет типы товаров, с указанием идентификатора типа и наименования.*
```sql
SELECT type_id, name
FROM product_types;
```
#### Результат:
type_id | name
:--- | :---
1 |	Физический
2 |	Цифровой
### Нужно получить идентификатор и наименование типа товара, поэтому в списке выборки инструкции **SELECT** указывается название соответствующих столбцов ***type_id,	name.***
---
> ### **5. В процессе работы достаточно часто возникает необходимость обращаться к таблицам, которые расположены в разных базах данных, при этом некоторые из них имеют одинаковые названия. Поэтому принято решение обращаться к таблицам в запросах, используя полный путь.**
> *Нужен запрос к таблице products, который выведет идентификатор товара и его наименование, при этом необходимо использовать полный путь к таблице.*
```sql
SELECT product_id, product_name
FROM TestDB3.dbo.products;
```
#### Результат:
product_id | product_name
:--- | :---
16 | Процессор V5
29 | Материнская плата R7Q
38 | Клавиатура S939
47 | Мышь N56
60 | Материнская плата ES20
71 | Принтер 3075
83 | Кулер для процессора D17
96 | Процессор V7
108 | Антивирусная программа
125 | Операционная система
### Необходимо обратиться к таблице ***products***, которая хранит информацию о товарах, при этом нужно получить не все столбцы таблицы, а только идентификатор и наименование товара. При этом чтобы уточнить местоположение таблицы, перед ее названием указываем базу данных и схему, в которой расположена эта таблица, ***TestDB3.dbo.products;***
---
> ### **6. В процессе эксплуатации системы возникла необходимость написать инструкцию, в которой будет много SQL запросов, при этом все эти запросы должны строго выполняться в контексте одной базы данных, допустим** ***TestDB3.*** 
> *Нужна инструкция, в которой принудительно переключается контекст на базу данных ***TestDB3*** так же выгрузка идентификаторов и ФИО всех покупателей, при этом в данном случае можно не указывать полный путь к таблице.*
```sql
USE TestDB3;
 
SELECT buyer_id, buyer_name
FROM buyers;
```
#### Результат:
buyer_id |	buyer_name
:--- | :---
753 | Зайцев А.Е.
832 | Иванов И.И.
991 | Попова Е.В.
1028 | John Smith
1109 | Сергеев А.С.
1201 | Андреев В.А.
### Для переключения контекста на базу данных ***TestDB3*** можно использовать команду ***USE.*** Нужно получить не все столбцы таблицы, а только идентификаторы и ФИО, поэтому в списке выборки инструкции ***SELECT*** указывается только два соответствующих столбца ***buyer_id, buyer_name.***
---
> ### **7. Появилась задача посмотреть информацию о заказах, в частности узнать номер и сумму всех заказов. Необходимо написать SQL запрос, который выведет номер и сумму всех заказов, и использовать псевдоним таблицы при обращении к соответствующим столбцам.** 
> *Нужен запрос, который выведет соответствующую информацию, при этом полученный запрос в будущем можно было модифицировать и добавлять в него соединения с другими таблицами, поэтому принято решение сразу использовать псевдоним таблицы и обращаться к столбцам этой таблицы через псевдоним.*
```sql
SELECT O.order_number,
	   O.order_summa
FROM orders AS O;
```
#### Результат:
order_number | order_summa
:--- | :---
151 | 12750,00
259 | 6700,00
307 | 21440,00
338 | 15540,00
352 | 2100,00
400 | 6700,00
410 | 12300,00
115 | 4600,00
85 | 23990,00
151 | 1300,00
244 | 7900,00
249 | 16900,00
298 | 900,00
338 | 2200,00
373 | 16740,00
### Нужно получить не все столбцы таблицы, а только номер и сумму заказа, поэтому в списке выборки инструкции ***SELECT*** указывается только два соответствующих столбца ***order_number, order_summa.*** При обращении к столбцам используется псевдоним таблицы, в которой находятся эти столбцы, в нашем случае это псевдоним «o», для этого перед названием столбца указывается псевдоним таблицы, т.е. «o».
---
> ### **8. Компания "КомпАсс" планирует увеличить стоимость товаров на 10%. Чтобы посмотреть на общую картину, необходимо выгрузить товары с их стоимостью, при этом включить в выгрузку еще и будущую их стоимость, т.е. с учетом 10% увеличения.**
> *Нужен запрос, который выведет наименование товара, текущую стоимость, а также в отдельном столбце сформирует будущую стоимость товара с учетом 10% увеличения.*
```sql
SELECT product_name, price, price * (100+10)/100 AS price_new
FROM products;
```
#### Результат:
product_name | price | price_new
:--- | :--- | :---
Процессор V5 | 13530,00 | 14883,00
Материнская плата R7Q |	5060,00 | 5566,00
Клавиатура S939 | 1430,00 |	1573,00
Мышь N56 | 990,00 | 1089,00
Материнская плата ES20 | 7370,00 | 8107,00
Принтер 3075 | 3850,00 | 4235,00
Кулер для процессора D17 | 495,00 |	544,50
Процессор V7 | 17094,00 | 18803,40
Антивирусная программа | 1200,00 | 1320,00
Операционная система | 6700,00 | 7370,00
### Используется выражение ***price * (100+10) / 100,*** которое сформирует столбец с тем же типом, что и столбец ***price.*** В результате получится выражение, формирующее значение цены товара, увеличенной на 10%. В случае для выражения, которое формирует стоимость товаров с учетом 10% увеличения цены, задан псевдоним ***price_new.***
---
> ### **9. Задача выгрузить список товаров с указанием наименования типа товара.**
> *Нужен запрос, который выведет наименование товара, его цену, а также наименование типа товара.*
```sql
 SELECT P.product_name,
        P.price,
		T.name AS type_name
 FROM products AS P
 INNER JOIN product_types AS T ON P.type_id = T.type_id;
```
#### Результат:
product_name | Price | type_name
:--- | :--- | :---
Процессор V5 | 13530,00 | Физический
Материнская плата R7Q |	5060,00 | Физический
Клавиатура S939 | 1430,00 |	Физический
Мышь N56 | 990,00 |	Физический
Материнская плата ES20 | 7370,00 | Физический
Принтер 3075 | 3850,00 | Физический
Кулер для процессора D17 | 495,00 |	Физический
Процессор V7 | 17094,00 | Физический
Антивирусная программа | 1200,00 | Цифровой
Операционная система | 6700,00 | Цифровой
### Товары хранятся в таблице ***products,*** типы товаров хранятся в таблице ***product_types*** (между этими таблицами существует логическая связь), поэтому чтобы написать запрос, который выведет и наименование товара, и наименование типа товара, необходимо выполнить соединение двух этих таблиц по ключу ***type_id.***
---
> ### **10. Задача составить список всех заказов, включая детализацию по товарам.**
> *Нужен запрос, который выведет номер и дату заказа, наименование товаров, которые включаются в тот или иной заказ, а также цену товаров.*
```sql
SELECT O.order_number,
       O.order_date,
	   P.product_name,
	   P.price
FROM orders as O 
INNER JOIN orders_products as OP on OP.order_id = O.order_id 
INNER JOIN products as P on P.product_id = OP.product_id;
```
### Результат:
order_number | order_date |	product_name | price
:--- | :--- | :--- | :---
151 | 2020-04-02 | Процессор V5 | 13530,00
151 | 2020-04-02 | Кулер для процессора D17 | 495,00
259 | 2020-04-17 | Операционная система | 6700,00
307 | 2020-05-02 | Материнская плата R7Q | 5060,00
307 | 2020-05-02 | Процессор V7 | 17094,00
307 | 2020-05-02 | Клавиатура S939 | 1430,00
338 | 2020-05-07 | Процессор V7 | 17094,00
352 | 2020-05-1 | Антивирусная программа | 1200,00
352 | 2020-05-16 | Мышь N56 |990,00
400	| 2020-05-21 | Материнская плата ES20 | 7370,00
410 | 2020-05-21 | Процессор V5 | 13530,00
115 | 2020-06-11 | Материнская плата R7Q | 5060,00
85 | 2020-06-29 | Материнская плата ES20 | 7370,00
85 | 2020-06-29 | Кулер для процессора D17  | 495,00
85 | 2020-06-29 | Процессор V7 | 17094,00
85 | 2020-06-29 | Клавиатура S939 | 1430,00
151 | 2020-07-02 | Клавиатура S939 | 1430,00
244 | 2020-07-30 | Антивирусная программа | 1200,00
244 | 2020-07-30 | Операционная система | 6700,00
249 | 2020-07-30 | Процессор V5 | 13530,00
249 | 2020-07-30 | Материнская плата R7Q | 5060,00
298 | 2020-08-08 | Мышь N56 | 990,00
338	| 2020-08-15 | Клавиатура S939 | 1430,00
338 | 2020-08-15 | Мышь N56 | 990,00
373 | 2020-08-23 | Антивирусная программа | 1200,00
373 | 2020-08-23 | Процессор V7 | 17094,00
### Заказы хранятся в таблице ***orders,*** товары хранятся в таблице ***products*** (между этими таблицами существует логическая связь), при этом между данными таблицами связь многие ко многим, поэтому прямой связи между ними нет, они связаны через связующую таблицу ***orders_products.*** Чтобы объединить заказы и товары, нужно соединить эти 3 таблицы.
---
> ### **11. Задача определить даты оформления заказов каждого клиента компании, т.е. в какие дни каждый из клиентов оформлял заказы.**
> *Нужен запрос, который выведет ФИО покупателей и даты оформления всех их заказов.*
```sql
SELECT B.buyer_name,
       O.order_date
FROM buyers AS B
LEFT JOIN orders AS O ON B.buyer_id = O.buyer_id;
```
#### Результат:
buyer_name | order_date
:--- | :---
Зайцев А.Е.| 2020-08-08
Иванов И.И. | 2020-05-02
Иванов И.И. | 2020-05-21
Иванов И.И. | 2020-06-11
Иванов И.И. | 2020-07-30
Иванов И.И. | 2020-08-23
Попова Е.В. | 2020-04-17
Попова Е.В. | 2020-07-30
John Smith | 2020-05-21
Сергеев А.С.| 2020-05-07
Сергеев А.С. | 2020-06-29
Андреев В.А. | 2020-04-02
Андреев В.А. | 2020-05-16
Андреев В.А. | 2020-07-02
Андреев В.А. | 2020-08-15
### Информация о покупателях хранится в таблице ***buyers,*** заказы хранятся в таблице ***orders*** (между этими таблицами существует логическая связь), поэтому чтобы написать запрос, который выведет и ФИО покупателей, и дату заказов, необходимо выполнить соединение двух этих таблиц. Соединение по идентификатору покупателя (***buyer_id***), так как данный ключ есть в обеих таблицах.
---
> ### **12. Появилась задача сформировать список цифровых товаров с их стоимостью.**
> *Нужен запрос, который покажет наименование и стоимость всех цифровых товаров.*
```sql
SELECT product_name, price
FROM products
WHERE type_id = 2;
```
#### Результат:
product_name | price
:--- | :---
Антивирусная программа | 1200,00
Операционная система | 6700,00
### Товары хранятся в таблице ***products,*** поэтому необходимо написать запрос к этой таблице. Получить нужно не все товары, а только цифровые, значит необходимо написать условие, которое оставит в результирующем наборе только цифровые товары. Тип товара отражается в столбце ***type_id,*** где значение 2 означает цифровой товар. Чтобы достать только цифровые товары, столбец с типом товара нужно сравнить в условии со значением 2.
---
> ### **13. Задача получить имена всех покупателей, которые родились позже 01.01.2000.**
> *Нужен запрос, который покажет имена и дату рождения соответствующих покупателей.*
```sql
SELECT buyer_name, birthday
FROM buyers
WHERE birthday > '2000.01.01';
```
#### Результат:
buyer_name | birthday
:--- | :---
Попова Е.В. | 2001-10-28
John Smith | 2000-05-03
### Информация о покупателях хранится в таблице ***buyers,*** значит нужно написать запрос к соответствующей таблице. Нужно получить не всех покупателей, а только тех, которые родились позже **01.01.2000,** поэтому нужно написать условие, которое оставит в результирующем наборе только подходящих под это условие покупателей.
---
> ### **14. Возникла задача выгрузить все данные заказов с идентификаторами: ***1708, 1959 и 2146.*****
> *Нужен запрос, который покажет все данные этих трех заказов.*
```sql
SELECT *
FROM orders
WHERE order_id IN (1708, 1959, 2146);
```
#### Результат:
order_id | buyer_id | order_number | order_date | order_summa
:--- | :--- | :--- | :--- | :---
1708 | 832 | 400 | 2020-05-21 | 6700,00
1959 | 201 | 151 | 2020-07-02 | 1300,00
2146 | 1201 | 338 |	2020-08-15 | 2200,00
### Заказы хранятся в таблице ***orders,*** поэтому нужно написать запрос именно к этой таблице. Так же нужно получить не все заказы, а только 3 заказа с конкретными идентификаторами. Поэтому необходимо в условии перечислить нужные айдишники закозов для их выгрузки.
---
> ### **15. Задача определить товары, которые каким либо образом связаны с процессором.**
> *Нужен запрос, который покажет наименование и стоимость соответствующих товаров.*
```sql
SELECT product_name, price
FROM products
WHERE product_name LIKE '%процессор%';
```
#### Результат:
product_name | price
:--- | :---
Процессор V5 | 13530,00
Кулер для процессора D17 | 495,00
Процессор V7 | 17094,00
### Товары хранятся в таблице ***products,*** значит необходимо написать запрос именно к этой таблице. Нужно получить не все товары, а только те, которые как-то связаны с процессором. Поэтому через условие нужно искать слово ***процессор*** в столбце наименования товара ***product_name***.
---
> ### **16. Задача сформировать список всех заказов с июня по июль 2020 года.**
> *Нужен запрос, который покажет номер и дату всех соответствующих заказов.*
```sql
SELECT order_number, order_date
FROM orders
WHERE order_date BETWEEN '2020.06.01' AND '2020.07.31';
```
#### Результат:
order_number | order_date
:--- | :---
115 | 2020-06-11
85 | 2020-06-29
151 | 2020-07-02
244 | 2020-07-30
249 | 2020-07-30
### Заказы хранятся в таблице ***orders,*** поэтому необходимо написать запрос именно к этой таблице. Нужно выгрузить не все заказы, а только те, которые были сделаны в  промежуток времени с 01.06.2020 по 31.07.2020.
---
> ### **17. Возникла необходимость определить физические товары, стоимость которых более 5000 рублей.**
> *Нужен запрос, который покажет наименование и цену таких товаров.*
```sql
SELECT product_name, price
FROM products
WHERE type_id = 1 AND price > 5000;
```
#### Результат:
product_name | price
:--- | :---
Процессор V5 | 13530,00
Материнская плата R7Q | 5060,00
Материнская плата ES20 | 7370,00
Процессор V7 | 17094,00
### Товары хранятся в таблице ***products,*** поэтому нужно написать запрос именно к этой таблице. Физические товары можно получить с помощью типа товара, затем добавляется условие с нужной ценой товара.
---
> ### **18. Задача выгрузить данные заказов, сделанных 30.07.2020, а также заказы с номерами 151 и 298.**
> *Нужен запрос, который покажет номер, дату и сумму соответствующих заказов.*
```sql
SELECT order_number, order_date, order_summa
FROM orders
WHERE order_date = '2020.07.30' OR order_number IN (151, 298);
```
#### Результат:
order_number | order_date |	order_summa
:--- | :--- | :---
151 | 2020-04-02 | 12750,00
151 | 2020-07-02 | 1300,00
244 | 2020-07-30 | 7900,00
249 | 2020-07-30 | 16900,00
298 | 2020-08-08 | 900,00
### Заказы хранятся в таблице ***orders,*** поэтому нужно написать запрос именно к этой таблице. Нужно получить не все заказы, а только те, которые были сделаны в определённый день, а также те, у которых номера равняются 151 и 298.
---
> ### **19. Задача сформировать список заказов, сделанных за Май 2020, при этом в список не должны попасть заказы с номерами 400 и 410.**
> *Нужен запрос, который сформирует данный список, в этом списке должна быть информация о номере заказа, дате и его сумме.*
```sql
SELECT order_number, order_date, order_summa
FROM orders
WHERE order_date BETWEEN '2020.05.01' AND '2020.05.31'
  AND order_number NOT IN (400, 410);
```
#### Результат:
order_number | order_date | order_summa
:--- | :--- | :---
307 | 2020-05-02 | 21440,00
338 | 2020-05-07 | 15540,00
352 | 2020-05-16 | 2100,00
### Нужно получить не все заказы, а только те, которые были сделаны в Мае 2020, но при этом нужно исключить заказы, у которых номера равняются 400 и 410. Необходимо составить такое условие, которое объединит два условия в одно, заказы сделанные за Май 2020 и исключение заказов с номерами 400, 410.
---
> ### **20. Задача составить список заказов за Июнь 2020, включая детализацию по товарам.**
> *Нужен запрос, который выведет номер и дату заказа, наименование товаров, которые включаются в тот или иной заказ, а также цену товаров.*
```sql
SELECT o.order_number, o.order_date, p.product_name, p.price
FROM orders o
INNER JOIN orders_products op ON o.order_id = op.order_id
INNER JOIN products p ON op.product_id = p.product_id
WHERE o.order_date BETWEEN '2020.06.01' AND '2020.06.30';
```
#### Результат:
order_number | order_date |	product_name | price
:--- | :--- | :--- | :---
115 | 2020-06-11 | Материнская плата R7Q | 5060,00
85 | 2020-06-29 | Клавиатура S939 | 1430,00
85 | 2020-06-29 | Материнская плата ES20 | 7370,00
85 | 2020-06-29 | Кулер для процессора D17 | 495,00
85 | 2020-06-29 | Процессор V7 | 17094,00
### Заказы хранятся в таблице ***orders,*** товары хранятся в таблице ***products,*** при этом между этими таблицами связь многие ко многим, поэтому прямой связи между ними нет, они связаны через связующую таблицу ***orders_products.*** Чтобы объединить заказы и товары, нужно соединить 3 эти таблицы и задать условие что список должен быть за Июнь 2020.
---
> ### **21. Задача определить, какие физические товары покупал «Иванов И.И.» в Мае 2020.**
> *Нужен запрос, который выведет имя покупателя, дату покупки и наименование товаров, которые он покупал.*
```sql
SELECT b.buyer_name, o.order_date, p.product_name
FROM buyers b
INNER JOIN orders o ON b.buyer_id = o.buyer_id
INNER JOIN orders_products op ON o.order_id = op.order_id
INNER JOIN products p ON op.product_id = p.product_id
WHERE b.buyer_name = 'Иванов И.И.'
  AND o.order_date BETWEEN '2020.05.01' AND '2020.05.31'
  AND p.type_id = 1;
```
#### Результат:
buyer_name | order_date | product_name
:--- | :--- | :---
Иванов И.И. | 2020-05-02 | Материнская плата R7Q
Иванов И.И. | 2020-05-02 | Клавиатура S939
Иванов И.И. | 2020-05-21 | Материнская плата ES20
Иванов И.И. | 2020-05-02 | Процессор V7
### Чтобы определить, какие физические товары покупал клиент ***Иванов И.И.*** необходимо соединить 4 таблицы, так как клиенты хранятся в таблице ***buyers,*** и они связаны только с заказами ***orders,*** а заказы в свою очередь связаны с товарами ***products*** через связующую таблицу ***orders_products.*** А в условии нужно добавить соответствующего клиента, дату его покупок и физический тип продукта.
---
> ### **22. Задача выгрузить список физических товаров, при этом нужно, что бы товары без описания в выгрузку не попали.**
> *Нужен запрос, который выведет наименование и описание всех физических товаров, кроме этого результирующий набор должен включать столбец, в котором будет уточнение, что это именно физический товар.*
```sql
SELECT pt.name AS type_name, p.product_name, p.description
FROM products p
INNER JOIN product_types pt ON p.type_id = pt.type_id
WHERE p.type_id =  1
  AND p.description IS NOT NULL;
```
#### Результат:
type_name |	product_name | description
:--- | :--- | :---
Физический | Процессор V5 |	4-ядерный процессор, 3600 МГц
Физический | Материнская плата R7Q | 2 слота DDR4, 1 слот PCI-E
Физический | Клавиатура S939 | Проводная, интерфейс USB
Физический | Мышь N56 |	USB
Физический | Материнская плата ES20 | 4 слота DDR4, 2 слота PCI-E
Физический | Принтер 3075 |	Лазерный, 20 стр/мин (A4), USB
Физический | Кулер для процессора D17 |	Нет описания
Физический | Процессор V7 |	6-ядерный процессор, 3700 МГц
### Товары хранятся в таблице ***products,*** типы товаров хранятся в таблице ***product_types,*** поэтому чтобы написать запрос, который выведет и наименование товара, и наименование типа товара, необходимо выполнить соединение двух этих таблиц по ключу ***type_id*** идентификатору типа, который есть в обеих таблицах. При этом нужно получить не все товары, а только физические, поэтому необходимо написать условие, которое оставит в результирующем наборе только физические товары. Тип физического товара отражается как значение 1. Чтобы оставить только физические товары, в условии нужно сравнить со значением 1, и в таком случае все записи, которые хранятся в столбце ***type_id*** со значением физический, попадут в результирующий набор данных. А так же нужно в услловии, исключить строки, в которых есть ***NULL*** значения.
---
> ### **23. Появилась необходимость узнать, нет ли в системе клиентов, которые зарегистрированы, но еще не сделали ни одного заказа.**
> *Нужен запрос, который выведет ФИО клиентов, не сделавших ни одного заказа, при этом в выгрузку необходимо включить столбец, который будет подтверждать данный факт, например, любой столбец из таблицы заказов, допустим **order_number,** т.е. он должен быть со значением NULL*
```sql
SELECT b.buyer_name, o.order_number
FROM buyers b
LEFT JOIN orders o ON b.buyer_id = o.buyer_id
WHERE o.order_number IS NULL;
```
### Результат:
buyer_name | order_number
:--- | :---
Петров С.Л. | NULL
### Информация о клиентах хранится в таблице ***buyers,*** заказы хранятся в таблице ***orders.*** Чтобы проверить, какие заказы оформляли клиенты, нужно соединить эти две таблицы. Соединять таблицы необходимо по идентификатору клиента ***buyer_id,*** так как данный ключ есть в обеих таблицах. Клиенты у которых в столбцах из таблицы заказов будут значения **NULL,** не сделали ни одного заказа, и именно их нужно выгрузить. Для этого в условии, необходимо указать столбец с номерами заказов и указть оператор ***IS NULL***.
---
> ### **24. Задача выгрузить детализацию по товарам заказа с номером 85, при этом в выгрузку не должны попасть товары, у которых не заполнено описание.**
> *Нужен запрос, который выведет номер заказа, наименование товаров, входящих в этот заказ, и описание товара, которое должно быть заполнено.*
```sql
SELECT o.order_number, p.product_name, p.description
FROM orders o
INNER JOIN orders_products op ON o.order_id = op.order_id
INNER JOIN products p ON op.product_id = p.product_id
WHERE o.order_number = 85
  AND p.description IS NOT NULL;
```
#### Результат:
order_number | product_name | description
:--- | :--- | :---
85 | Клавиатура S939 | Проводная, интерфейс USB
85 | Материнская плата ES20 | 4 слота DDR4, 2 слота PCI-E
85 | Кулер для процессора D17 | Нет описания
85 | Процессор V7 |	6-ядерный процессор, 3700 МГц
### Заказы хранятся в таблице ***orders,*** товары хранятся в таблице ***products,*** при этом между этими таблицами связь многие ко многим, поэтому прямой связи между ними нет, они связаны через связующую таблицу ***orders_products.*** Чтобы объединить заказы и товары, нужно соединить 3 таблицы. Нужно получить не все заказы, а только один заказ с определённым номером, заказ номер 85. Поэтому необходимо написать условие, которое оставит в результирующем наборе только один этот заказ. Для этого столбец с номером заказа нужно сравнить со значением 85 и в таком случае все записи которые хранятся в столбце ***order_number*** с значением 85, попадут в результирующий набор данных. Кроме этого необходимо исключить товары без описания с помощью оператора ***IS NOT NULL.***
---
> ### **25. Появилась необходимость, узнать какие товары в магазине не пользуются спросом, в связи с этим возникла задача, определить товары которые еще никто не покупал.**
> *Нужен запрос, который выведет наименование таких товаров и их цену.*
```sql
SELECT p.product_name, p.price
FROM products p
LEFT JOIN orders_products op ON p.product_id = op.product_id
WHERE op.product_id IS NULL;
```
#### Результат:
product_name | price
:--- | :---
Принтер 3075 | 3850,00
### Чтобы определить товары, которые еще никто не покупал, достаточно проверить, какие товары не включаются ни в один заказ. Для этого нужно соединить таблицы ***products,*** в которой хранятся товары, и ***orders_products,*** в которой хранится связь товаров и заказов, т.е. если для каких-то товаров нет ни одной соответствующей записи в связующей таблице, значит эти товары не входят ни в один заказ и соответственно, их никто еще не покупал. 
---
> ### **26. Задача сформировать перечень дней оформления заказов за Май 2020, т.е. в какие дни месяца оформлялись заказы, при этом если в один день совершалось несколько заказов, то в выборке все равно должна отражаться только одна строка с датой, дублей быть не должно.**
> *Нужен запрос, который выведет соответствующую информацию.*
```sql
SELECT DISTINCT order_date
FROM orders
WHERE order_date BETWEEN '2020.05.01' AND '2020.05.31';
```
#### Результат:
order_date |
:--- |
2020-05-02 
2020-05-07 
2020-05-16 
2020-05-21 
### Заказы хранятся в таблице ***orders,*** поэтому необходимо написать запрос именно к этой таблице. Чтобы сформировать перечень дней оформления заказов за Май 2020, сначала необходимо получить все заказы, которые были оформлены в этот период. В списке выборки нужно вывести всего один столбец с датой заказа ***order_date,*** однако в Мае 2020 есть дни, в которых было оформлено несколько заказов, поэтому в результирующем наборе будут дублированные строки, и чтобы исключить их, т.е. оставить только уникальные даты используется оператор **DISTINCT.**
---
> ### **27. Задача выгрузить список товаров с указанием цены, но не всех товаров, а только небольшой произвольной части, например, половину товаров.**
> *Нужен запрос, который выведет половину всех товаров. Результирующий набор должен включать наименование и цену товара.*
```sql
SELECT TOP 50 PERCENT product_name, price
FROM products;
```
#### Результат:
product_name | price
:--- | :---
Процессор V5 | 13530,00
Материнская плата R7Q |	5060,00
Клавиатура S939 | 1430,00
Мышь N56 | 990,00
Материнская плата ES20 | 7370,00
### Товары хранятся в таблице ***products,*** поэтому необходимо написать запрос именно к этой таблице. Нужно получить не все товары, а только половину, поэтому можно использовать фильтр **TOP** с параметром **50 PERCENT,** который оставит в результирующем наборе данных только 50 % данных, т.е. половину строк. В выборке нужно вывести не все столбцы, а только наименование и цену, поэтому указывается два соответствующих столбца ***product_name, price.***
---
> ### **28. Задача сформировать список покупателей, которые приобретали цифровые товары.**
> *Нужен запрос, который выведет ФИО покупателей, которые хотя бы раз покупали цифровой товар в магазине.*
```sql
SELECT DISTINCT b.buyer_name
FROM buyers b
INNER JOIN orders o ON b.buyer_id = o.buyer_id
INNER JOIN orders_products op ON o.order_id = op.order_id
INNER JOIN products p ON op.product_id = p.product_id
WHERE p.type_id = 2;
```
#### Результат:
buyer_name |
:--- |
Андреев В.А.
Иванов И.И.
Попова Е.В.
### Чтобы определить покупателей, которые приобретали цифровые товары, необходимо соединить 4 таблицы. Информация о покупателях хранится в таблице ***buyers,*** заказы хранятся в таблице ***orders,*** однако в таблице заказов не хранится детализация по товарам, а эта информация нужна, чтобы определить тип товара, поэтому необходимо провести соединение еще и с таблицей ***products,*** а между таблицей ***orders*** и ***products*** связь многие ко многим, поэтому прямой связи между ними нет, они связаны через связующую таблицу ***orders_products.*** Анализировать необходимо не все товары, а только цифровые, поэтому нужно написать условие, которое оставит в результирующем наборе только цифровые товары. Тип товара отражается в столбце ***type_id,*** где значение 2 означает цифровой товар. В списке выборки нужно вывести всего один столбец с ФИО покупателя из таблицы ***buyers,*** однако один и тот же покупатель мог приобретать цифровые товары несколько раз, поэтому в результирующем наборе будут дублированные строки, и чтобы исключить их, т.е. оставить только уникальных покупателей используется оператор **DISTINCT.**
---
> ### **29. Задача выгрузить любые два физических товара, которые приобретал покупатель «Сергеев А.С.» в Июне 2020.**
> *Нужен запрос, который выведет ФИО покупателя, т.е. «Сергеев А.С.», и наименование двух физических товаров, которые он покупал в Июне 2020.*
```sql
SELECT TOP (2) b.buyer_name, p.product_name
FROM buyers b
INNER JOIN orders o ON b.buyer_id = o.buyer_id
INNER JOIN orders_products op ON o.order_id = op.order_id
INNER JOIN products p ON op.product_id = p.product_id
WHERE b.buyer_name = 'Сергеев А.С.'
  AND o.order_date BETWEEN '2020.06.01' AND '2020.06.30'
  AND p.type_id = 1;
```
#### Результат:
buyer_name | product_name
:--- | :---
Сергеев А.С. | Клавиатура S939
Сергеев А.С. | Материнская плата ES20
### Чтобы вывести покупателя, а также физические товары, которые он приобретал, необходимо соединить 4 таблицы. Информация о покупателях хранится в таблице ***buyers,*** заказы хранятся в таблице ***orders,*** а товары хранятся в таблице ***products,*** однако между таблицей ***orders и products*** связь многие ко многим, поэтому прямой связи между ними нет, они связаны через связующую таблицу ***orders_products.*** Чтобы отфильтровать итоговые данные в соответствии с условием, нужно поставить три условия и соединить их с помощью оператора **AND,** (Покупатель = Сергеев А.С.), (Период = Июнь 2020), (Тип товара = физический). Кроме этого, нужно получить не все товары, подходящие под данное условие, а только два, поэтому можно использовать фильтр **TOP** с параметром 2, который оставит в результирующем наборе только 2 строки данных.
---
> ### **30. Задача выгрузить минимальную, максимальную и среднюю сумму заказа за период с Мая по Июнь 2020.**
> *Нужен запрос, который сформирует соответствующую информацию. В результирующий набор должно включаться 3 столбца, которые будут отражать минимальную, максимальную и среднюю сумму заказа.* 
```sql
SELECT MIN(order_summa) AS min_summa,
       MAX(order_summa) AS max_summa,
       AVG(order_summa) AS avg_summa
FROM orders
WHERE order_date BETWEEN '2020.05.01' AND '2020.06.30';
```
#### Решение:
min_summa |	max_summa |	avg_summa
:--- | :--- | :---
2100,00 | 23990,00 | 12381,4285
### Заказы хранятся в таблице ***orders,*** поэтому необходимо написать запрос именно к этой таблице. Нужно анализировать не все заказы, а только с Мая по Июнь 2020, поэтому нужно в условии использовать оператор **BETWEEN.** Для определения минимальной, максимальной и средней суммы заказа нужно использовать агрегатные функции, в качестве параметра им необходимо передать столбец, в котором хранится сумма заказа, в частности ***order_summa.*** А с помощью алиасов задать названия соответствующим столбцам.
---
> ### **31. Задача узнать, на какую сумму каждый из покупателей сделал заказы в магазине, т.е. сколько всего денег потратил каждый из покупателей.**
> *Нужен запрос, который выведет имя покупателя и общую сумму денег, которую он потратил.*
```sql
SELECT b.buyer_name, SUM(o.order_summa) AS summa
FROM buyers b
LEFT JOIN orders o ON b.buyer_id = o.buyer_id
GROUP BY b.buyer_name;
```
#### Результат:
buyer_name | summa
:--- | :---
John Smith | 12300,00
Андреев В.А. | 18350,00
Зайцев А.Е. | 900,00
Иванов И.И. | 57380,00
Попова Е.В. | 23600,00
Сергеев А.С. | 39530,00
### Чтобы узнать, на какую сумму каждый из покупателей сделал заказы, необходимо просуммировать все заказы покупателя. Для этого нужно соединить таблицы ***buyers*** и ***orders,*** в таблице ***buyers*** хранится информация о покупателях, в таблице ***orders*** информация о заказах. Соединять таблицы нужно по идентификатору покупателя ***buyer_id,*** так как данный ключ есть в обеих таблицах. С помощью агрегатной функции **SUM** просуммируются заказы в таблице ***orders,*** передав в функцию столбец с суммой заказа, в частности ***order_summa.*** Задаётся псевдоним **summa** для столбца, который формируется функцией **SUM.** В секции **GROUP BY** указывается столбец с ФИО покупателя, так как его указали в списке выборки, т.е. группировка будет происходить по этому столбцу, таким образом группируются данные по каждому покупателю.
---
> ### **32. Задача подсчитать, сколько всего товаров было продано с разбивкой по типу товара, т.е. сколько было продано физических товаров и сколько было продано цифровых товаров.**
> *Нужен запрос, который выведет наименование типа товара и количество продаж.*
```sql
SELECT pt.name AS type_name, COUNT(*) AS quantity_sales
FROM product_types pt
INNER JOIN products p ON pt.type_id = p.type_id
INNER JOIN orders_products op ON p.product_id = op.product_id
GROUP BY pt.name;
```
#### Результат:
type_name |	quantity_sales
:--- | :---
Физический | 21
Цифровой | 5
### Чтобы определить, сколько всего товаров было продано, нужно подсчитать, сколько всего раз товары участвовали в заказах, т.е. по факту сколько записей с идентификатором каждого товара есть в таблице ***orders_products.*** Для этого необходимо соединить таблицы ***products*** и ***orders_products.*** Кроме этого необходимо сгруппировать данные по типу товара, а наименование типа товара хранится в таблице ***product_types.*** Таким образом, нужно соединить 3 таблицы, и с помощью агрегатной функции **COUNT**, подсчить количество упоминаний товаров в таблице ***orders_products,*** передав в функцию символ звездочки. И с помощью алиаса, назначить название ***quantity_sales*** для столбца который формируется функцией **COUNT.** А столбцу ***name,*** назначить алиас ***type_name.*** В секции **GROUP BY,** указывается столбец с наименованием типа товара, так как он указывается в списке выборки, т.е. необходимо сгруппировать данные по этому столбцу, таким образом группируются данные по типу товара.
---
> ### **33. Задача определить, сколько единиц каждого товара было продано за все время.**
> *Нужен запрос, который выведет идентификатор товара, наименование товара и количество продаж*
```sql
SELECT p.product_id, p.product_name,
       COUNT(op.product_id) AS quantity_sales
FROM products p
LEFT JOIN orders_products op ON p.product_id = op.product_id
GROUP BY p.product_id, p.product_name;
```
#### Результат:
product_id | product_name |	quantity_sales
:--- | :--- | :---
108 | Антивирусная программа | 3
38 | Клавиатура S939 | 4
83 | Кулер для процессора D17 |	2
60 | Материнская плата ES20 | 2
29 | Материнская плата R7Q | 3
47 | Мышь N56 |	3
125 | Операционная система | 2
71 | Принтер 3075 |	0
16 | Процессор V5 |	3
96 | Процессор V7 |	4
### Чтобы определить, сколько всего товаров было продано, нужно подсчитать, сколько всего раз все товары участвовали в заказах, т.е. по факту сколько записей с идентификатором каждого товара есть в таблице ***orders_products.*** Для этого необходимо соединить таблицы ***products*** и ***orders_products.*** С помощью агрегатной функции **COUNT** подсчитывается количество упоминаний товаров в таблице ***orders_products,*** в функцию необходимо передать столбец из таблицы, на основе которой будут вычисляться продажи, в данном случае столбец ***product_id*** из таблицы ***orders_products.*** В списке выборки необходимо вывести идентификатор товара и наименование товара, поэтому в секции **GROUP BY** нужно указать соответствующие столбцы, так как они будут указаны в списке выборки, т.е. необходимо сгруппировать данные по этим столбцам, сначала группируются по идентификатору, а затем по наименованию товара.
---
